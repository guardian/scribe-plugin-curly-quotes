{"version":3,"file":"scribe-plugin-curly-quotes.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../src/scribe-plugin-curly-quotes.js"],"sourcesContent":["define('scribe-plugin-curly-quotes',[], function () {\n\n  'use strict';\n\n  return function () {\n\n    var openDoubleCurly = '“';\n    var closeDoubleCurly = '”';\n\n    var openSingleCurly = '‘';\n    var closeSingleCurly = '’';\n\n    var NON_BREAKING_SPACE = '\\u00A0';\n\n    return function (scribe) {\n      /**\n       * Run the formatter as you type on the current paragraph.\n       *\n       * FIXME: We wouldn't have to do this if the formatters were run on text\n       * node mutations, but that's expensive unil we have a virtual DOM.\n       */\n\n      var keys = {\n        34: '\"',\n        39: '\\''\n      };\n      var curlyQuoteChar;\n\n      // `input` doesn't tell us what key was pressed, so we grab it beforehand\n      scribe.el.addEventListener('keypress', function (event) {\n        curlyQuoteChar = keys[event.charCode];\n      });\n\n      // When the character is actually inserted, format it to transform.\n      scribe.el.addEventListener('input', function (event) {\n        if (curlyQuoteChar) {\n          var selection = new scribe.api.Selection();\n          var pElement = selection.getContaining(function (node) {\n            return node.nodeName === 'P';\n          });\n          selection.placeMarkers();\n          pElement.innerHTML = substituteCurlyQuotes(pElement.innerHTML);\n          selection.selectMarkers();\n          // Reset\n          curlyQuoteChar = undefined;\n        }\n      });\n\n      // Substitute quotes on setting content or paste\n      scribe.registerHTMLFormatter('normalize', substituteCurlyQuotes);\n\n      function isWordCharacter(character) {\n          return /[^\\s()]/.test(character);\n      }\n\n      function substituteCurlyQuotes(html) {\n        // We don't want to replace quotes within the HTML markup\n        // (e.g. attributes), only to text nodes\n        var holder = document.createElement('div');\n        holder.innerHTML = html;\n\n        // Replace straight single and double quotes with curly\n        // equivalent in the given string\n        mapTextNodes(holder, function(str) {\n          // Tokenise HTML elements vs text between them\n          // Note: this is escaped HTML in the text node!\n          // Split by elements\n          var tokens = str.split(/(<[^>]+?>(?:.*<\\/[^>]+?>)?)/);\n          return tokens.map(function(token) {\n            // Only replace quotes in text between (potential) HTML elements\n            if (/^</.test(token)) {\n              return token;\n            } else {\n              return convert(token);\n            }\n          }).join('');\n        });\n\n        return holder.innerHTML;\n      }\n\n      // Recursively convert the quotes to curly quotes. We have to do this\n      // recursively instead of with a global match because the latter would\n      // not detect overlaps, e.g. \"'1'\" (text can only be matched once).\n      function convert(str) {\n        if (! /['\"]/.test(str)) {\n          return str;\n        } else {\n          var foo = str.\n            // Use [\\s\\S] instead of . to match any characters _including newlines_\n            replace(/([\\s\\S])?'([\\s\\S])?/,\n                    replaceQuotesFromContext(openSingleCurly, closeSingleCurly)).\n            replace(/([\\s\\S])?\"([\\s\\S])?/,\n                    replaceQuotesFromContext(openDoubleCurly, closeDoubleCurly));\n          return convert(foo);\n        }\n      }\n\n      function replaceQuotesFromContext(openCurly, closeCurly) {\n        return function(m, prev, next) {\n          prev = prev || '';\n          next = next || '';\n          var isStart = ! prev;\n          var isEnd = ! next;\n          var hasCharsBefore = isWordCharacter(prev);\n          var hasCharsAfter  = isWordCharacter(next);\n          // Optimistic heuristic, would need to look at DOM structure\n          // (esp block vs inline elements) for more robust inference\n          if (hasCharsBefore || (isStart && ! hasCharsAfter && ! isEnd)) {\n            return prev + closeCurly + next;\n          } else {\n            return prev + openCurly + next;\n          }\n        };\n      }\n\n      // Apply a function on all text nodes in a container, mutating in place\n      function mapTextNodes(container, func) {\n        var walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);\n        var node = walker.firstChild();\n        if (node) {\n          do {\n            node.data = func(node.data);\n          } while ((node = walker.nextSibling()));\n        }\n\n        return node;\n      }\n\n    };\n  };\n\n});\n\n"],"names":[]}
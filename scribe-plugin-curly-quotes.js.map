{"version":3,"file":"scribe-plugin-curly-quotes.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA,AD0CA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../src/constants.js","../src/formatters.js","../src/arrays.js","../src/scribe-plugin-curly-quotes.js"],"sourcesContent":["define('constants',[], function () {\n  return {\n    openDoubleCurly: '“',\n    closeDoubleCurly: '”',\n    openSingleCurly: '‘',\n    closeSingleCurly: '’'\n  }\n});\n\n","define('formatters',['./constants'], function (constants) {\n\n  function isWordCharacter(character) {\n      return /[^\\s()]/.test(character);\n  }\n\n  function replaceQuotesFromContext(openCurly, closeCurly) {\n    return function(m, prev) {\n      prev = prev || '';\n      var hasCharsBefore = isWordCharacter(prev);\n      // Optimistic heuristic, would need to look at DOM structure\n      // (esp block vs inline elements) for more robust inference\n      if (hasCharsBefore) {\n        return prev + closeCurly;\n      } else {\n        return prev + openCurly;\n      }\n    };\n  }\n\n  // Recursively convert the quotes to curly quotes. We have to do this\n  // recursively instead of with a global match because the latter would\n  // not detect overlaps, e.g. \"'1'\" (text can only be matched once).\n  function convert(str) {\n    if (! /['\"]/.test(str)) {\n      return str;\n    } else {\n      var foo = str.\n        // Use [\\s\\S] instead of . to match any characters _including newlines_\n        replace(/([\\s\\S])?'/,\n                replaceQuotesFromContext(constants.openSingleCurly, constants.closeSingleCurly)).\n        replace(/([\\s\\S])?\"/,\n                replaceQuotesFromContext(constants.openDoubleCurly, constants.closeDoubleCurly));\n      return convert(foo);\n    }\n  }\n\n  return {\n    convert: convert\n  }\n});\n\n","define('arrays',[], function() {\n\n  function toArray(nodeList) {\n    var array = [];\n    if (nodeList && nodeList.length && nodeList.item) {\n      for (var i = 0; i < nodeList.length; i++) {\n        var item = nodeList.item(i);\n        if (item) {\n          array.push(item);\n        }\n      }\n    }\n    return array;\n  }\n\n  return {\n    toArray: toArray\n  };\n});\n\n","define('scribe-plugin-curly-quotes',[\n  './constants',\n  './formatters',\n  './arrays'\n], function (\n  constants,\n  formatters,\n  arrays\n) {\n\n  'use strict';\n\n  return function () {\n\n    return function (scribe) {\n      /**\n       * Run the formatter as you type on the current paragraph.\n       *\n       * FIXME: We wouldn't have to do this if the formatters were run on text\n       * node mutations, but that's expensive unil we have a virtual DOM.\n       */\n\n      var curlyQuoteChar;\n\n      var elementHelpers = scribe.node;\n\n      // `input` doesn't tell us what key was pressed, so we grab it beforehand\n      scribe.el.addEventListener('keypress', function (event) {\n        var keys = {\n          34: '\"',\n          39: '\\''\n        };\n\n        curlyQuoteChar = keys[event.charCode];\n      });\n\n      // When the character is actually inserted, format it to transform.\n      scribe.el.addEventListener('input', function () {\n        if (curlyQuoteChar) {\n          var selection = new scribe.api.Selection();\n          var containingBlockElement = scribe.allowsBlockElements()\n            ? selection.getContaining(elementHelpers.isBlockElement)\n            : scribe.el;\n\n          selection.placeMarkers();\n          containingBlockElement.innerHTML = substituteCurlyQuotes(containingBlockElement.innerHTML);\n          selection.selectMarkers();\n          // Reset\n          curlyQuoteChar = undefined;\n        }\n      });\n\n      // Substitute quotes on setting content or paste\n      scribe.registerHTMLFormatter('normalize', substituteCurlyQuotes);\n\n      function substituteCurlyQuotes(html) {\n        // We don't want to replace quotes within the HTML markup\n        // (e.g. attributes), only to text nodes\n        var holder = document.createElement('div');\n        holder.innerHTML = html;\n\n        // Replace straight single and double quotes with curly\n        // equivalent in the given string\n        mapElements(holder, function(prev, str) {\n          // Tokenise HTML elements vs text between them\n          // Note: this is escaped HTML in the text node!\n          // Split by elements\n          // We tokenise with the previous text nodes for context, but\n          // only extract the current text node.\n          var tokens = (prev + str).split(/(<[^>]+?>(?:.*<\\/[^>]+?>)?)/);\n          return tokens\n            .map(function(token) {\n              // Only replace quotes in text between (potential) HTML elements\n              if (/^</.test(token)) {\n                return token;\n              } else {\n                return formatters.convert(token);\n              }\n            })\n            .join('')\n            .slice(prev.length);\n        });\n\n        return holder.innerHTML;\n      }\n\n      // Apply a function on all text nodes in a container, mutating in place\n      function mapElements(containerElement, func) {\n        // TODO: This heuristic breaks for elements that contain a mixture of\n        // inline and block elements.\n        var nestedBlockElements = arrays.toArray(containerElement.children).filter(elementHelpers.isBlockElement);\n        if (nestedBlockElements.length) {\n          nestedBlockElements.forEach(function (nestedBlockElement) {\n            // Map the nested block elements\n            mapElements(nestedBlockElement, func);\n          });\n        } else {\n          mapTextNodes(containerElement, func);\n        }\n      }\n\n      function mapTextNodes(containerElement, func) {\n        // TODO: Only walk inside of text nodes within inline elements\n        var walker = document.createTreeWalker(containerElement, NodeFilter.SHOW_TEXT);\n        var node = walker.firstChild();\n        var prevTextNodes = '';\n        while (node) {\n          // Split by BR\n          if (node.previousSibling && node.previousSibling.nodeName === 'BR') {\n            prevTextNodes = '';\n          }\n          node.data = func(prevTextNodes, node.data);\n          prevTextNodes += node.data;\n          node = walker.nextSibling();\n        }\n      }\n\n    };\n  };\n\n});\n\n"],"names":[]}
{"version":3,"file":"scribe-plugin-curly-quotes.min.js","mappings":"AAAAA,OAAA,eAAA,WACA,OACAC,gBAAA,IACAC,iBAAA,IACAC,gBAAA,IACAC,iBAAA,OAIAJ,OCTA,cAAA,eAAA,SAAAK,GAEA,QAAAC,GAAAC,GACA,MAAA,UAAAC,KAAAD,GAGA,QAAAE,GAAAC,EAAAC,GACA,MAAA,UAAAC,EAAAC,GACAA,EAAAA,GAAA,EACA,IAAAC,GAAAR,EAAAO,EAGA,OAAAC,GACAD,EAAAF,EAEAE,EAAAH,GAQA,QAAAK,GAAAC,GACA,GAAA,OAAAR,KAAAQ,GAEA,CACA,GAAAC,GAAAD,EAEAE,QAAA,aACAT,EAAAJ,EAAAF,gBAAAE,EAAAD,mBACAc,QAAA,aACAT,EAAAJ,EAAAJ,gBAAAI,EAAAH,kBACA,OAAAa,GAAAE,GARA,MAAAD,GAYA,OACAD,QAAAA,KCtCAf,OD0CA,YAAA,WCxCA,QAAAmB,GAAAC,GACA,GAAAC,KACA,IAAAD,GAAAA,EAAAE,QAAAF,EAAAG,KACA,IAAA,GAAAC,GAAA,EAAAA,EAAAJ,EAAAE,OAAAE,IAAA,CACA,GAAAD,GAAAH,EAAAG,KAAAC,EACAD,IACAF,EAAAI,KAAAF,GAIA,MAAAF,GAGA,OACAF,QAAAA,KAIAnB,OCpBA,8BACA,cACA,eACA,YACA,SACAK,EACAqB,EACAC,GAKA,MAAA,YAEA,MAAA,UAAAC,GAyCA,QAAAC,GAAAC,GAGA,GAAAC,GAAAC,SAAAC,cAAA,MAyBA,OAxBAF,GAAAG,UAAAJ,EAIAK,EAAAJ,EAAA,SAAAlB,EAAAG,GAMA,GAAAoB,IAAAvB,EAAAG,GAAAqB,MAAA,8BACA,OAAAD,GACAE,IAAA,SAAAC,GAEA,MAAA,KAAA/B,KAAA+B,GACAA,EAEAb,EAAAX,QAAAwB,KAGAC,KAAA,IACAC,MAAA5B,EAAAS,UAGAS,EAAAG,UAIA,QAAAC,GAAAO,EAAAC,GAGA,GAAAC,GAAAjB,EAAAR,QAAAuB,EAAAG,UAAAC,OAAAC,EAAAC,eACAJ,GAAAtB,OACAsB,EAAAK,QAAA,SAAAC,GAEAf,EAAAe,EAAAP,KAGAQ,EAAAT,EAAAC,GAIA,QAAAQ,GAAAT,EAAAC,GAKA,IAHA,GAAAS,GAAApB,SAAAqB,iBAAAX,EAAAY,WAAAC,WACAC,EAAAJ,EAAAK,aACAC,EAAA,GACAF,GAEAA,EAAAG,iBAAA,OAAAH,EAAAG,gBAAAC,WACAF,EAAA,IAEAF,EAAAK,KAAAlB,EAAAe,EAAAF,EAAAK,MACAH,GAAAF,EAAAK,KACAL,EAAAJ,EAAAU,cA3FA,GAAAC,GAEAhB,EAAAnB,EAAA4B,IAGA5B,GAAAoC,GAAAC,iBAAA,WAAA,SAAAC,GACA,GAAAC,IACAC,GAAA,IACAC,GAAA,IAGAN,GAAAI,EAAAD,EAAAI,YAIA1C,EAAAoC,GAAAC,iBAAA,QAAA,WACA,GAAAF,EAAA,CACA,GAAAQ,GAAA,GAAA3C,GAAA4C,IAAAC,UACAC,EAAA9C,EAAA+C,sBACAJ,EAAAK,cAAA7B,EAAAC,gBACApB,EAAAoC,EAEAO,GAAAM,eACAH,EAAAxC,UAAAL,EAAA6C,EAAAxC,WACAqC,EAAAO,gBAEAf,EAAAgB,UAKAnD,EAAAoD,sBAAA,YAAAnD","sources":["../src/constants.js","../src/formatters.js","../src/arrays.js","../src/scribe-plugin-curly-quotes.js"],"sourcesContent":["define('constants',[], function () {\n  return {\n    openDoubleCurly: '“',\n    closeDoubleCurly: '”',\n    openSingleCurly: '‘',\n    closeSingleCurly: '’'\n  }\n});\n\n","define('formatters',['./constants'], function (constants) {\n\n  function isWordCharacter(character) {\n      return /[^\\s()]/.test(character);\n  }\n\n  function replaceQuotesFromContext(openCurly, closeCurly) {\n    return function(m, prev) {\n      prev = prev || '';\n      var hasCharsBefore = isWordCharacter(prev);\n      // Optimistic heuristic, would need to look at DOM structure\n      // (esp block vs inline elements) for more robust inference\n      if (hasCharsBefore) {\n        return prev + closeCurly;\n      } else {\n        return prev + openCurly;\n      }\n    };\n  }\n\n  // Recursively convert the quotes to curly quotes. We have to do this\n  // recursively instead of with a global match because the latter would\n  // not detect overlaps, e.g. \"'1'\" (text can only be matched once).\n  function convert(str) {\n    if (! /['\"]/.test(str)) {\n      return str;\n    } else {\n      var foo = str.\n        // Use [\\s\\S] instead of . to match any characters _including newlines_\n        replace(/([\\s\\S])?'/,\n                replaceQuotesFromContext(constants.openSingleCurly, constants.closeSingleCurly)).\n        replace(/([\\s\\S])?\"/,\n                replaceQuotesFromContext(constants.openDoubleCurly, constants.closeDoubleCurly));\n      return convert(foo);\n    }\n  }\n\n  return {\n    convert: convert\n  }\n});\n\n","define('arrays',[], function() {\n\n  function toArray(nodeList) {\n    var array = [];\n    if (nodeList && nodeList.length && nodeList.item) {\n      for (var i = 0; i < nodeList.length; i++) {\n        var item = nodeList.item(i);\n        if (item) {\n          array.push(item);\n        }\n      }\n    }\n    return array;\n  }\n\n  return {\n    toArray: toArray\n  };\n});\n\n","define('scribe-plugin-curly-quotes',[\n  './constants',\n  './formatters',\n  './arrays'\n], function (\n  constants,\n  formatters,\n  arrays\n) {\n\n  'use strict';\n\n  return function () {\n\n    return function (scribe) {\n      /**\n       * Run the formatter as you type on the current paragraph.\n       *\n       * FIXME: We wouldn't have to do this if the formatters were run on text\n       * node mutations, but that's expensive unil we have a virtual DOM.\n       */\n\n      var curlyQuoteChar;\n\n      var elementHelpers = scribe.node;\n\n      // `input` doesn't tell us what key was pressed, so we grab it beforehand\n      scribe.el.addEventListener('keypress', function (event) {\n        var keys = {\n          34: '\"',\n          39: '\\''\n        };\n\n        curlyQuoteChar = keys[event.charCode];\n      });\n\n      // When the character is actually inserted, format it to transform.\n      scribe.el.addEventListener('input', function () {\n        if (curlyQuoteChar) {\n          var selection = new scribe.api.Selection();\n          var containingBlockElement = scribe.allowsBlockElements()\n            ? selection.getContaining(elementHelpers.isBlockElement)\n            : scribe.el;\n\n          selection.placeMarkers();\n          containingBlockElement.innerHTML = substituteCurlyQuotes(containingBlockElement.innerHTML);\n          selection.selectMarkers();\n          // Reset\n          curlyQuoteChar = undefined;\n        }\n      });\n\n      // Substitute quotes on setting content or paste\n      scribe.registerHTMLFormatter('normalize', substituteCurlyQuotes);\n\n      function substituteCurlyQuotes(html) {\n        // We don't want to replace quotes within the HTML markup\n        // (e.g. attributes), only to text nodes\n        var holder = document.createElement('div');\n        holder.innerHTML = html;\n\n        // Replace straight single and double quotes with curly\n        // equivalent in the given string\n        mapElements(holder, function(prev, str) {\n          // Tokenise HTML elements vs text between them\n          // Note: this is escaped HTML in the text node!\n          // Split by elements\n          // We tokenise with the previous text nodes for context, but\n          // only extract the current text node.\n          var tokens = (prev + str).split(/(<[^>]+?>(?:.*<\\/[^>]+?>)?)/);\n          return tokens\n            .map(function(token) {\n              // Only replace quotes in text between (potential) HTML elements\n              if (/^</.test(token)) {\n                return token;\n              } else {\n                return formatters.convert(token);\n              }\n            })\n            .join('')\n            .slice(prev.length);\n        });\n\n        return holder.innerHTML;\n      }\n\n      // Apply a function on all text nodes in a container, mutating in place\n      function mapElements(containerElement, func) {\n        // TODO: This heuristic breaks for elements that contain a mixture of\n        // inline and block elements.\n        var nestedBlockElements = arrays.toArray(containerElement.children).filter(elementHelpers.isBlockElement);\n        if (nestedBlockElements.length) {\n          nestedBlockElements.forEach(function (nestedBlockElement) {\n            // Map the nested block elements\n            mapElements(nestedBlockElement, func);\n          });\n        } else {\n          mapTextNodes(containerElement, func);\n        }\n      }\n\n      function mapTextNodes(containerElement, func) {\n        // TODO: Only walk inside of text nodes within inline elements\n        var walker = document.createTreeWalker(containerElement, NodeFilter.SHOW_TEXT);\n        var node = walker.firstChild();\n        var prevTextNodes = '';\n        while (node) {\n          // Split by BR\n          if (node.previousSibling && node.previousSibling.nodeName === 'BR') {\n            prevTextNodes = '';\n          }\n          node.data = func(prevTextNodes, node.data);\n          prevTextNodes += node.data;\n          node = walker.nextSibling();\n        }\n      }\n\n    };\n  };\n\n});\n\n"],"names":["define","openDoubleCurly","closeDoubleCurly","openSingleCurly","closeSingleCurly","constants","isWordCharacter","character","test","replaceQuotesFromContext","openCurly","closeCurly","m","prev","hasCharsBefore","convert","str","foo","replace","toArray","nodeList","array","length","item","i","push","formatters","arrays","scribe","substituteCurlyQuotes","html","holder","document","createElement","innerHTML","mapElements","tokens","split","map","token","join","slice","containerElement","func","nestedBlockElements","children","filter","elementHelpers","isBlockElement","forEach","nestedBlockElement","mapTextNodes","walker","createTreeWalker","NodeFilter","SHOW_TEXT","node","firstChild","prevTextNodes","previousSibling","nodeName","data","nextSibling","curlyQuoteChar","el","addEventListener","event","keys",34,39,"charCode","selection","api","Selection","containingBlockElement","allowsBlockElements","getContaining","placeMarkers","selectMarkers","undefined","registerHTMLFormatter"]}